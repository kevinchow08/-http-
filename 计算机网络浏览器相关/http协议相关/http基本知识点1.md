## 经典面试题：键入网址再按下回车，后面究竟发生了什么？

1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；
2. 浏览器用 TCP 的三次握手与服务器建立连接；HTTP 协议是运行在 TCP/IP 基础上的，依靠 TCP/IP 协议来实现数据的可靠传输。所以浏览器要用 HTTP 协议收发数据，首先要做的就是建立 TCP 连接。
3. 有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。浏览器向服务器发送拼好的请求报文；底层走的还是 TCP 协议。
4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；
5. 浏览器和服务器直接的请求和响应发出给对方之后，对方都要通过TCP协议回复一个 ACK 确认
6. 浏览器解析报文及其对应的外链再次向服务器请求，之后则是将资源渲染输出页面。

![图示](./httpAssets/8a5bddd3d8046daf7032c7d60a3d1a19.png)

### 总结：
+ HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；
+ HTTP 是通过 TCP 完成端口到端口的数据传输的。一个 TCP 连接可以传输多个 HTTP 请求、响应。(Connection: keep-alive)
+ 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；
+ 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；
+ 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现「短路」操作；
+ 虽然现实中的 HTTP 传输过程非常复杂，但理论上仍然可以简化成实验里的「两点」模型。

## HTTP的报文结构

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息；
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中前两部分起始行和头部字段经常又合称为 **请求头** 或 **响应头**，消息正文又称为 **实体**，但与 **header** 对应，很多时候就直接称为 **body** 。

### 请求行
三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
3. 版本号：表示报文使用的 HTTP 协议版本。

`GET / HTTP/1.1`

在这个请求行里，`GET` 是请求方法，`/` 是请求目标，`HTTP/1.1` 是版本号，把这三部分连起来，意思就是「服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。」


### 状态行

服务器响应的状态，同样也是由三部分构成：

1. 版本号：表示报文使用的 HTTP 协议版本；
2. 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；
3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

`HTTP/1.1 200 OK` `HTTP/1.1 404 Not Found`

意思就是：
+ 「浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。」
+ 「抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是 404 」


### 头部字段

请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的**请求头或响应头**

头部字段是 key-value 的形式，key 和 value 之间用 `: ` 分隔，最后用 CRLF 换行表示字段结束。比如在 `Host: 127.0.0.1` 这一行里 key 就是 `Host`，value 就是 `127.0.0.1`。

HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以 **任意添加自定义头** ，这就给 HTTP 协议带来了无限的扩展可能。

### 常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

1. 通用字段：在请求头和响应头里都可以出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。

#### Host
+ 首先要说的是 **Host** 字段，它属于 **请求字段**，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求 **必须出现** 的字段
+ Host 请求头**指明了请求将要发送到的服务器主机名和端口号**
+ Host 字段告诉服务器这个**请求应该由哪个主机来处理**，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择

例如: 在 127.0.0.1 上有三个虚拟主机：`www.chrono.com` 、`www.metroid.net` 和 `origin.io` （这三个域名通过 www//conf/http/servers/xx.conf 各自定义的）。那么当使用域名的方式访问时，就必须要用 Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理


#### User-Agent

这是一个请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。

爬虫也是一种User-Agent

#### Date

**Date** 字段是一个 **通用字段** ，但**通常出现在响应头**里，**表示 HTTP 报文创建的时间**，客户端可以使用这个时间再搭配其他字段决定缓存策略。

#### **Server**

**Server** 字段是 **响应字段**，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号。不是必须要出现的

### Content-Length

实体字段里要说的一个是 **Content-Length** ，它**表示报文里 body 的长度**，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输

## 请求方法：
请求方法的实际含义就是客户端发出了一个「动作指令」，要求服务器端对 URI 定位的资源执行这个动作。
目前 HTTP/1.1 规定了八种方法，单词 **都必须是大写的形式**

![如图](./httpAssets/3cdc8ac71b80929f4a94dfeb9ffe4b6d.jpg)

### GET/HEAD
+ **GET** 方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的， 它的含义是请求 **从服务器获取资源** ，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。

+ **HEAD** 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头。
HEAD 方法可以看做是 GET 方法的一个「简化版」或者「轻量版」。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。

+ 比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。

### POST/PUT

+ GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，**向 URI 指定的资源提交数据，数据就放在报文的 body 里**。
+ PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同：通常 POST 表示的是「新建（create）」的含义，而 PUT 则是「修改（update）」的含义。

### 其他方法

+ DELETE：指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是**对资源做一个删除标记**（逻辑删除）。当然，更多的时候服务器就直接不处理 DELETE 请求。
+ OPTIONS：方法要求服务器列出可对资源实行的操作方法（HTTP Method），**在响应头的 Allow 字段里返回**。用途：CORS跨域共享中进行非简单请求时，要先发出一个预检请求来询问，是否允许之后跨源请求。
+ 注意：
     1. 逻辑删除就是对要被删除的数据打上一个删除标记，在逻辑上是数据是被删除的，但数据本身依然存在！
     2. 而物理删除则是把数据从介质上彻底删除掉。
    
## URI和URL

提问：用什么来标记服务器上的资源呢？ 怎么区分「这个」资源和「那个」资源呢？
用的是 URI，也就是 **统一资源标识符**（Uniform Resource Identifier）

### URI 的格式
+ URI 本质上是一个字符串，这个字符串的作用是 **唯一地标记资源的位置或者名字** 。
+ 它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而 **资源** 既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。

下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。
![URI](./httpAssets/46581d7e1058558d8e12c1bf37d30d2a.png)
由此可以看出URL是URI的子集。

+ scheme 表示 **资源应该使用哪种协议** 来访问。
+ 在 `://` 之后，表示 **资源所在的主机名** ，通常的形式是 `host:port` ，即主机名加端口号。
+ 有了协议名和主机地址、端口号，再加上后面 **标记资源所在位置** 的 **path**（采用了类似文件系统 **目录路径** 的表示方式） ，浏览器就可以连接服务器访问资源了。
+ URI 的查询参数：仅用 `协议名 + 主机名 + 路径` 的方式是无法适应这些场景的，所以 URI 后面还有一个 **query** 部分，它在 path 之后，用一个 `?` 开始，但不包含 `?` ，表示对资源附加的额外要求。
+ 查询参数 query 有一套自己的格式，是多个 **key=value** 的字符串，这些 KV 值用字符 **&** 连接。与此同时，Chrome 的开发者工具（Query String Parameters）也能解码出 query 里的 KV 对

### URI 的编码
在 URI 里对非 ASCII 码或特殊字符，汉字必须要做转义，否则服务器收到 HTTP 报文后会无法正确处理。
其规则是：将其**转换成十六进制字节值** ，然后前面再加上一个 `%`

+ 例如: 空格被转义成 `%20`，`?` 被转义成 `%3F` 。而中文、日文等则通常使用 UTF-8 编码后再转义，例如 `银河` 会被转义 `%E9%93%B6%E6%B2%B3`

+ 有了这个编码规则后，URI 就更加完美了，可以支持任意的字符集用任何语言来标记资源。
`http://www.chrono.com:8080/11-1? 夸父逐日` => `http://www.chrono.com:8080/11-1?%20%E5%A4%B8%E7%88%B6%E9%80%90%E6%97%A5`

+ 或者，可以使用JS方法来查看`encodeURI(str)`转义  `decodeURI`反转义

提问：HTTP 协议允许在在请求行里使用完整的 URI，但为什么浏览器没有这么做呢？
答：节省带宽资源，协议里起始行和 host 已经包含了

## 响应状态码的使用

状态码可以理解为： **HTTP 数据处理的状态** 

**RFC 标准把状态码分成了五类** 

- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- 2××：成功，报文已经收到并被正确处理；
    - **200 OK**：
      是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，**通常在响应头后都会有 body 数据**。
    - **204 No Content**：
      是另一个很常见的成功状态码，它的含义与 `200 OK` 基本相同，**但响应头后没有 body 数据**。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。
    - **206 Partial Content**：
      是 HTTP 分块下载或断点续传的基础，在客户端发送 **范围请求**、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。
- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
    - **301 Moved Permanently**：
      俗称 **永久重定向** ，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。
    - **302 Found**：
      与 301 类似，曾经的描述短语是 **Moved Temporarily** ，俗称 **临时重定向** ，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。
    - **304 Not Modified**：
      用于缓存控制。它不具有通常的跳转含义。但可以理解成 **重定向已到缓存的文件**（即缓存重定向）。
- 4××：客户端错误，请求报文有误，服务器无法处理；
    - **400 Bad Request**：
        是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误。
    - **403 Forbidden**：
        实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个闭门羹。
    - **404 Not Found**：
        可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。
- 5××：客户端请求报文正确，但服务器在处理时内部发生了错误
    - **500 Internal Server Error**：
        与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。
    - **501 Not Implemented**：
        表示客户端请求的功能还不支持，这个错误码比 500 要温和一些，和即将开业，敬请期待的意思差不多，不过具体什么时候开业就不好说了。
    - **502 Bad Gateway**：
        通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。
    - **503 Service Unavailable**：
        表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的「网络服务正忙，请稍后重试」的提示信息就是状态码 503。 503 是一个「临时」的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个 **Retry-After** 字段，指示客户端可以在多久以后再次尝试发送请求。

## HTTP的特点总结：
1. HTTP 是灵活可扩展的，可以**任意添加头字段实现任意功能**；
2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。
6. eg: **无状态** 形象地来说就是没有记忆能力，服务器无法判断两个请求是否是同一个浏览器发过来的，所以会导致重复严重客户端的 身份

## HTTP的缺点：
1. HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
2. HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
3. HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。
