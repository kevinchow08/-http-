# xss与csrf攻击

## XSS攻击

在 HTML 页面中展示的文本，理应不可执行。但是 XSS 漏洞被利用，变成了可解析、可执行的代码。
这些恶意代码，**包装成参数** 传递给前端或后端

XSS 攻击的本质： **前端或后端盲目相信外部参数 (入参)**

## XSS 的种类

1. 反射型XSS： 攻击者在第一方 URL 上拼接恶意参数，并诱使受害者点击，受害者将向服务器后端请求 HTML。同时携带了这个恶意的 URL 参数。服务器没有校验这个恶意参数，而是使用它，并返回了包含恶意逻辑的页面。这在传统的 Web 架构上会发生，比如 PHP 等在后端渲染模板的方式
2. DOM型XSS： 对于现代的 SPA 页面来说，前端页面直接处理 URL 参数（获取路由参数），不需要经过后端。如果前端没有校验这个恶意参数，而是使用它，通过 DOM API 加入到页面（比如：显示路由参数id，name），同样会导致页面出现恶意代码（这是纯粹发生在客户端的攻击）。
3. 存储型XSS： 恶意代码存储在了服务器后端的数据库中。后端又将其取出渲染到了 HTML 页面中。比如 XSS 事故多发区：发表评论时，该评论中有恶意的`<script>`语句，被存储在数据库中，当页面需要向所有人显示评论的时候，又被渲染在前端页面上。此时，前端页面没有转义`<script>`语句，而是直接插入到了标签中。最后导致`<script>`被执行。

通常，**反射型XSS 和 DOM型XSS** 被认为是**非持久型**，**存储型XSS 被认为是持久型**。持久的意思就是数据存储在数据库中的意思。非持久型的恶意参数一般是不会储存在数据库中的，只可能出现在日志文件中。

## XSS 攻击的防范

1. HttpOnly 防止劫取 Cookie：浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。攻击者可以通过**注入恶意脚本**获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。
2. 输入检查：不要相信用户的任何输入。对于用户的任何输入要进行**检查、过滤和转义**。**建立可信任的字符和 HTML 标签白名单**，对于不在白名单之列的字符或者标签进行过滤或编码。
3. 服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。
4. 充分利用 CSP： HTTP头部配置`Content-Security-Policy: policy` 一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；

两个问题：
1. 为了预防XSS攻击，我们会对用户的输入内容进行过滤，转义的时机应该是：
     + 输入时前端处理
     + 落库时后端处理
     + 拼接HTML时
2. XSS攻击的预防，需要前端还是后端去做？


+ 对用户输入内容转义，其时机必须在拼接HTML时，如果在落库前处理，会导致iOS/安卓乱码；
+ XSS攻击的预防，需要RD一起完成，存储型和反射型攻击是后端的责任，DOM型是前端的责任；

## CSRF攻击

CSRF 攻击是攻击者借助**受害者的 Cookie**骗取服务器的信任，可以在受害者毫不知情的情况下**以受害者名义伪造请求发送给受攻击服务器**

而 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

### 通过 Cookie 进行 CSRF 攻击

假设有一个 bbs 站点：`http://www.c.com`，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：`http://www.c.com:8002/content/delete/:id`

如发起 `http://www.c.com:8002/content/delete/87343` 请求时，会删除 id 为 87343 的帖子。

当用户登录之后，会设置如下 cookie：
`res.setHeader('Set-Cookie', ['user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;']);`

user 对应的值是用户 ID。然后构造一个页面 A：
页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接：
```
<p>CSRF 攻击者准备的网站：</p>
<img src="http://www.c.com:8002/content/delete/87343">
```
可以看到，当登录用户访问攻击者的网站时，会向 `www.c.com` 发起一个删除用户帖子的请求。此时若用户在切换到 `www.c.com` 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。

在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。

## CSRF 攻击的防范

1. 充分利用好Cookie的SameSite属性：在 **HTTP 响应头**中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能**实现从第三方站点发送请求时禁止 Cookie 的发送**，
2. 验证请求的来源站点：**Referer 是 HTTP 请求头中的一个字段，记录了该HTTP请求的来源地址**。因此服务器可以禁止来自第三方站点的请求。
3. CSRF Token的方式：第三方站点发送请求时无法获取到页面中的token，所以无法发送恶意请求。

注意：
+ Origin 属性只包含了域名信息，并没有包含具体的 URL 路径
+ Referer 属性包含了具体的URL路径信息。