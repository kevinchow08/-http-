## HTTP 的缓存代理

代理服务收到源服务器发来的响应数据后需要做两件事:(转发和数据缓存)

- 第一个当然是把报文转发给客户端
- 而第二个就是把报文存入自己的 Cache 里。

下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽。

### 来自源服务器的缓存控制

前面介绍了 4 种服务器端的 `Cache-Control` 属性：max-age、no_store、no_cache 和 must-revalidate。
这 4 种缓存属性 **可以约束客户端，也可以约束代理**

但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。

1. 所以，为了**要区分客户端上的缓存和代理上的缓存** ，可以使用两个新属性 **private** 和 **public** ：
- `private` 表示缓存只能在客户端保存，是用户 **私有** 的，不能放在代理上与别人共享。
- `public` 的意思就是缓存完全开放，谁都可以存，谁都可以用。

2. 其次，**缓存失效后的重新验证也要区分开**（即使用条件请求 `Last-modified` 和 `ETag` ）
+ **must-revalidate** 是只要客户端的缓存过期就必须回源服务器验证
+ 而 **proxy-revalidate** 只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。

3. 再次，**缓存的生存时间** 可以使用新的 **s-maxage**，只限定在代理上能够存多久。
而客户端仍然使用 `max_age` 。

4. 还有一个代理专用的属性 **no-transform** 。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而 `no-transform` 就会禁止这样做，不许偷偷摸摸搞小动作。


这些新的缓存控制属性比较复杂，还是用便利店冷柜来举例好理解一些。

+ 水果上贴着标签 `private, max-age=5` 。这就是说水果不能放进冷柜，必须直接给顾客，保鲜期 5 天，过期了还得去超市重新进货。
+ 冻鱼上贴着标签 `public, max-age=5, s-maxage=10` 。这个的意思就是可以在冰柜里存 10 天，但顾客那里只能存 5 天，过期了可以来便利店取，只要在 10 天之内就不必再找超市。
+ 排骨上贴着标签 `max-age=30, proxy-revalidate, no-transform` 。因为缓存默认是 public（这里有争议，很多地方写的 private） 的，那么它在便利店和顾客的冰箱里就都可以存 30 天，过期后便利店必须去超市进新货，而且不能擅自把大排改成小排。
