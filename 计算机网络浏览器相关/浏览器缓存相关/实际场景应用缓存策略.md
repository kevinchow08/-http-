# 缓存方案的应用与解析
目前最流行的前端框架比如 Vue、React 等都以单页应用（SPA）的开发模式著称。当我们访问首页时，浏览器率先加载的便是 HTML 文件。后续继续加载一些首页渲染需要以及公共的资源文件，当我们跳转页面时会**异步加载**下一个页面所需的资源，实现页面的组装及逻辑处理。

问：刷新页面或再次访问时大部分资源都命中了强缓存，唯独率先加载的 **HTML 资源走了协商缓存**，这是为什么？？

+ index.html的请求头中有配置`cache-control: max-age=0`字段（使浏览器强缓存失效），该资源不使用强缓存，因为我们期望浏览器每次加载时都应该向服务器询问是否更新（配合服务端返回的缓存标识etag或者last-modified，启用协商缓存），并且它的文件名是不会改变的。
+ 如果index.html使用强缓存，有可能导致访问的是旧资源。
+ 而index.html所引用的JS资源在打包部署的时候会生成唯一的hash值。每次部署hash值会更新，浏览器会当作一个新的资源去向服务器请求。
+ 如果index.html所引用的JS资源hash值没有变，则代表资源没有更新，便会优先读取浏览器缓存（强缓存）。

所以，根据 HTTP 缓存的规则最终我们便可以总结出如下缓存方案：
+ 频繁变动的资源，比如 HTML， 采用协商缓存：在请求头中设置 `cache-control: no-cache; max-age=0` 或者使用**meta标签的http-equiv**属性来设置。
+ 不常变化的资源：CSS、JS、图片资源等采用强缓存。使用 hash 命名
+ `cache-control`在服务端和客户端中都可以进行设置

## Chrome 的三种加载模式

1. 正常重新加载
2. 硬性重新加载
3. 清空缓存并硬性重新加载。
   
三种模式只在开发者工具打开时才能够使用。
  

+ 正常重新加载：
这种模式就是常说的“刷新网页”，用户触发该模式在控制台可以看到大多数资源会命中强缓存。并且，很大一部分资源会命中from memory cache。
+ 硬性重新加载：
**硬性重新加载并没有清空缓存，而是禁用缓存**。本质上是在请求资源的请求头上加 `cache-control: no-cache`.从而使得请求资源不命中强缓存，必须去访问服务器。
+ 清空缓存并硬性重新加载：
**触发该操作会将浏览器存储的本地缓存都清空掉后再重新向服务器发送请求**，同时其影响的并不是当前网站，所有访问过的网站缓存都将被清除。

### 为什么硬性重新加载还是命中了缓存？
+ 因为硬性重新加载并没有清空缓存，而执行硬性重新加载 在页面渲染完毕后，异步资源才插入进来，此刻加载异步资源还是会优先读取缓存。并且异步资源都没有被加上`cache-control: no-cache`.
+ 同时base64图片也会命中缓存，Base64 格式的图片被塞进 memory cache 可以视作浏览器为节省渲染开销的“自保行为”。

注意：
+ no-cache：
在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(**进行协商缓存验证**)。
+ no-store：
缓存不应存储有关客户端请求或服务器响应的任何内容，即**不使用任何缓存**。

## Memory Cache 与 Disk Cache

+ Memory Cache： 
  + 优点：获取速度快、优先级高，从内存中获取资源耗时为 0 ms
  + 缺点：生命周期短，当网页关闭后内存就会释放。受限制于计算机内存的大小，缓存有限

+ Disk Cache：
  + 优点：是生命周期长，不触发删除操作则一直存在，
  + 缺点：则是获取资源的速度相对内存缓存较慢

缓存获取顺序：
1. 浏览器会率先查找内存缓存，如果资源在内存中存在，那么直接从内存中加载
2. 如果内存中没找到，接下去会去磁盘中查找，找到便从磁盘中获取
3. 如果磁盘中也没有找到，那么就进行网络请求，并将请求后符合条件的资源存入内存和磁盘中

问：浏览器判断一个资源是存入内存缓存还是磁盘缓存的依据是什么？

结论之一： **浏览器内存缓存生效的前提下，JS 资源的执行加载时间会影响其是否被内存缓存。** 而 CSS 资源比较与众不同，其被磁盘缓存的概率远大于被内存缓存。

